import {
  require_events
} from "./chunk-PTBKMDVE.js";
import {
  StatusCodes,
  TransportError,
  TransportRaceCondition,
  TransportStatusError,
  init_lib_es
} from "./chunk-3RTBC6LS.js";
import {
  __toESM
} from "./chunk-2E63JINA.js";

// node_modules/@ledgerhq/hw-transport/lib-es/Transport.js
var import_events = __toESM(require_events());
init_lib_es();
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var Transport = (
  /** @class */
  function() {
    function Transport2() {
      var _this = this;
      this.exchangeTimeout = 3e4;
      this.unresponsiveTimeout = 15e3;
      this.deviceModel = null;
      this._events = new import_events.default();
      this.send = function(cla, ins, p1, p2, data, statusList) {
        if (data === void 0) {
          data = Buffer.alloc(0);
        }
        if (statusList === void 0) {
          statusList = [StatusCodes.OK];
        }
        return __awaiter(_this, void 0, void 0, function() {
          var response, sw;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (data.length >= 256) {
                  throw new TransportError("data.length exceed 256 bytes limit. Got: " + data.length, "DataLengthTooBig");
                }
                return [4, this.exchange(Buffer.concat([
                  Buffer.from([cla, ins, p1, p2]),
                  Buffer.from([data.length]),
                  data
                ]))];
              case 1:
                response = _a.sent();
                sw = response.readUInt16BE(response.length - 2);
                if (!statusList.some(function(s) {
                  return s === sw;
                })) {
                  throw new TransportStatusError(sw);
                }
                return [2, response];
            }
          });
        });
      };
      this.exchangeAtomicImpl = function(f) {
        return __awaiter(_this, void 0, void 0, function() {
          var resolveBusy, busyPromise, unresponsiveReached, timeout, res;
          var _this2 = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (this.exchangeBusyPromise) {
                  throw new TransportRaceCondition("An action was already pending on the Ledger device. Please deny or reconnect.");
                }
                busyPromise = new Promise(function(r) {
                  resolveBusy = r;
                });
                this.exchangeBusyPromise = busyPromise;
                unresponsiveReached = false;
                timeout = setTimeout(function() {
                  unresponsiveReached = true;
                  _this2.emit("unresponsive");
                }, this.unresponsiveTimeout);
                _a.label = 1;
              case 1:
                _a.trys.push([1, , 3, 4]);
                return [4, f()];
              case 2:
                res = _a.sent();
                if (unresponsiveReached) {
                  this.emit("responsive");
                }
                return [2, res];
              case 3:
                clearTimeout(timeout);
                if (resolveBusy)
                  resolveBusy();
                this.exchangeBusyPromise = null;
                return [
                  7
                  /*endfinally*/
                ];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      this._appAPIlock = null;
    }
    Transport2.prototype.exchange = function(_apdu) {
      throw new Error("exchange not implemented");
    };
    Transport2.prototype.setScrambleKey = function(_key) {
    };
    Transport2.prototype.close = function() {
      return Promise.resolve();
    };
    Transport2.prototype.on = function(eventName, cb) {
      this._events.on(eventName, cb);
    };
    Transport2.prototype.off = function(eventName, cb) {
      this._events.removeListener(eventName, cb);
    };
    Transport2.prototype.emit = function(event) {
      var _a;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      (_a = this._events).emit.apply(_a, __spreadArray([event], __read(args), false));
    };
    Transport2.prototype.setDebugMode = function() {
      console.warn("setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.");
    };
    Transport2.prototype.setExchangeTimeout = function(exchangeTimeout) {
      this.exchangeTimeout = exchangeTimeout;
    };
    Transport2.prototype.setExchangeUnresponsiveTimeout = function(unresponsiveTimeout) {
      this.unresponsiveTimeout = unresponsiveTimeout;
    };
    Transport2.create = function(openTimeout, listenTimeout) {
      var _this = this;
      if (openTimeout === void 0) {
        openTimeout = 3e3;
      }
      return new Promise(function(resolve, reject) {
        var found = false;
        var sub = _this.listen({
          next: function(e) {
            found = true;
            if (sub)
              sub.unsubscribe();
            if (listenTimeoutId)
              clearTimeout(listenTimeoutId);
            _this.open(e.descriptor, openTimeout).then(resolve, reject);
          },
          error: function(e) {
            if (listenTimeoutId)
              clearTimeout(listenTimeoutId);
            reject(e);
          },
          complete: function() {
            if (listenTimeoutId)
              clearTimeout(listenTimeoutId);
            if (!found) {
              reject(new TransportError(_this.ErrorMessage_NoDeviceFound, "NoDeviceFound"));
            }
          }
        });
        var listenTimeoutId = listenTimeout ? setTimeout(function() {
          sub.unsubscribe();
          reject(new TransportError(_this.ErrorMessage_ListenTimeout, "ListenTimeout"));
        }, listenTimeout) : null;
      });
    };
    Transport2.prototype.decorateAppAPIMethods = function(self, methods, scrambleKey) {
      var e_1, _a;
      try {
        for (var methods_1 = __values(methods), methods_1_1 = methods_1.next(); !methods_1_1.done; methods_1_1 = methods_1.next()) {
          var methodName = methods_1_1.value;
          self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (methods_1_1 && !methods_1_1.done && (_a = methods_1["return"]))
            _a.call(methods_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    Transport2.prototype.decorateAppAPIMethod = function(methodName, f, ctx, scrambleKey) {
      var _this = this;
      return function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return __awaiter(_this, void 0, void 0, function() {
          var _appAPIlock;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                _appAPIlock = this._appAPIlock;
                if (_appAPIlock) {
                  return [2, Promise.reject(new TransportError("Ledger Device is busy (lock " + _appAPIlock + ")", "TransportLocked"))];
                }
                _a.label = 1;
              case 1:
                _a.trys.push([1, , 3, 4]);
                this._appAPIlock = methodName;
                this.setScrambleKey(scrambleKey);
                return [4, f.apply(ctx, args)];
              case 2:
                return [2, _a.sent()];
              case 3:
                this._appAPIlock = null;
                return [
                  7
                  /*endfinally*/
                ];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
    };
    Transport2.ErrorMessage_ListenTimeout = "No Ledger device found (timeout)";
    Transport2.ErrorMessage_NoDeviceFound = "No Ledger device found";
    return Transport2;
  }()
);
var Transport_default = Transport;

export {
  Transport_default
};
//# sourceMappingURL=chunk-LORBLO3D.js.map

{
  "version": 3,
  "sources": ["../../@ledgerhq/hw-transport/src/Transport.ts"],
  "sourcesContent": ["import EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportRaceCondition,\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError,\n} from \"@ledgerhq/errors\";\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage,\n};\n\n/**\n */\nexport type Subscription = {\n  unsubscribe: () => void;\n};\n\n/**\n */\nexport type Device = any; // Should be a union type of all possible Device object's shape\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport interface DescriptorEvent<Descriptor> {\n  type: \"add\" | \"remove\";\n  descriptor: Descriptor;\n  deviceModel?: DeviceModel | null | undefined;\n  device?: Device;\n}\n\n/**\n */\nexport type Observer<Ev> = Readonly<{\n  next: (event: Ev) => unknown;\n  error: (e: any) => unknown;\n  complete: () => unknown;\n}>;\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\n\nexport default class Transport {\n  exchangeTimeout = 30000;\n  unresponsiveTimeout = 15000;\n  deviceModel: DeviceModel | null | undefined = null;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static readonly isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static readonly list: () => Promise<Array<any>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\n  const sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n  })\n   */\n  static readonly listen: (\n    observer: Observer<DescriptorEvent<any>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\n  TransportFoo.open(descriptor).then(transport => ...)\n   */\n  static readonly open: (\n    descriptor?: any,\n    timeout?: number\n  ) => Promise<Transport>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: (...args: Array<any>) => any): void {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: any): void {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number): void {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout: number): void {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data,\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n\n    if (!statusList.some((s) => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout = 3000,\n    listenTimeout?: number\n  ): Promise<Transport> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: (e) => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: (e) => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        },\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: Promise<void> | null | undefined;\n  exchangeAtomicImpl = async (\n    f: () => Promise<Buffer | void>\n  ): Promise<Buffer | void> => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportRaceCondition(\n        \"An action was already pending on the Ledger device. Please deny or reconnect.\"\n      );\n    }\n\n    let resolveBusy;\n    const busyPromise: Promise<void> = new Promise((r) => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    let unresponsiveReached = false;\n    const timeout = setTimeout(() => {\n      unresponsiveReached = true;\n      this.emit(\"unresponsive\");\n    }, this.unresponsiveTimeout);\n\n    try {\n      const res = await f();\n\n      if (unresponsiveReached) {\n        this.emit(\"responsive\");\n      }\n\n      return res;\n    } finally {\n      clearTimeout(timeout);\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Record<string, any>,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (const methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock: string | null = null;\n\n  decorateAppAPIMethod<R, A extends any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: any,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],
  "mappings": "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",
  "names": ["Transport", "EventEmitter", "_this"]
}
